
// 2 9 10
#include <iostream>
#include <queue>
using namespace std;
struct Tree          //дерево
{
    int key;         //ключ
    char text[5];    //текст - не более 4 букв
    Tree* Left, * Right;
};

Tree* makeTree(Tree* Root);       //Создание дерева
Tree* list(int i, char* s);       //Создание нового элемента
Tree* insertElem(Tree* Root, int key, char* s);  //Добавление нового элемента
Tree* search(Tree* n, int key);   //Поиск элемента по ключу 
Tree* delet(Tree* Root, int key); //Удаление элемента по ключу
void view(Tree* t, int level);    //Вывод дерева 
int count(Tree* t, char letter);  //Подсчет количества слов
void delAll(Tree* t);             //Очистка дерева
void levelOrderTraversal(Tree* root); // 3
int countRightLeaves(Tree* root);
int countRightLeaves(Tree* root); // 2
int countNodesWithValueK(Tree* node, int k); // 9
int sumOfKeys(Tree* node); // 10
int countEvenKeys(Tree* node); // 12
void printLevelSum(Tree* p1); // твоя

int c = 0;         //количество слов
Tree* Root = NULL;   //указатель корня

void main()
{
    setlocale(0, "Russian");
    int key, choice, n;
    Tree* rc; char s[5], letter;
    for (;;)
    {
        cout << "1 -  создание дерева\n";
        cout << "2 -  добавление элемента\n";
        cout << "3 -  поиск по ключу\n";
        cout << "4 -  удаление элемента\n";
        cout << "5 -  вывод дерева\n";
        cout << "6 -  подсчет количества букв\n";
        cout << "7 -  очистка дерева\n";
        cout << "8 -  вывод всех элементов дерева по уровням\n";
        cout << "9 -  (2var)вывод количества листьев дерева, которые являются правыми дочерними вершинами\n";
        cout << "10 -  (9var) вывод количества вершин дерева, значение которых равно k\n";
        cout << "11 -  (10var) вывод суммы значений всех вершин данного дерева\n";
        cout << "12 -  вывести сумму значений вершин каждого уровня\n";
        cout << "0 -  выход\n";
        cout << "ваш выбор?\n";
        cin >> choice;
        cout << "\n";
        switch (choice)
        {
        case 1:  Root = makeTree(Root);  break;
        case 2:  cout << "\nВведите ключ: "; cin >> key;
            cout << "Введите слово: "; cin >> s;
            insertElem(Root, key, s); break;
        case 3:  cout << "\nВведите ключ: ";  cin >> key;
            rc = search(Root, key);
            cout << "Найденное слово= ";
            puts(rc->text); break;
        case 4:  cout << "\nВведите удаляемый ключ: "; cin >> key;
            Root = delet(Root, key);  break;
        case 5:  if (Root->key >= 0)
        {
            cout << "Дерево повернуто на 90 град. влево" << endl;
            view(Root, 0);
        }
              else cout << "Дерево пустое\n"; break;
        case 6:  cout << "\nВведите букву: "; cin >> letter;
            n = count(Root, letter);
            cout << "Количество слов, начинающихся с буквы " << letter;
            cout << " равно " << n << endl; break;
        case 7:  delAll(Root); break;
        case 8: levelOrderTraversal(Root); break;
        case 9: {
            int ress = countRightLeaves(Root);
            cout << "Количество листьев дерева, которые являются правыми дочерними вершинами равно " << ress << endl;
            break;
        }
        case 10: {
            int k;
            cout << "Введите k "; cin >> k;
            int numNodesWithK = countNodesWithValueK(Root, k);
            cout << "Количество вершин со значением " << k << ": " << numNodesWithK << endl;
            break;
        }
        case 11: {
            int sum = sumOfKeys(Root);
            cout << "Сумма значений ключей всех вершин дерева: " << sum << endl;
            break;
        }
        case 12: {
            printLevelSum(Root);
            break;
        }
        case 0:  exit(0);
        }
    }
}

Tree* makeTree(Tree* Root)    //Создание дерева
{
    int key; char s[5];
    cout << "Конец ввода - отрицательное число\n\n";
    if (Root == NULL)  // если дерево не создано
    {
        cout << "Введите ключ корня: "; cin >> key;
        cout << "Введите слово корня: "; cin >> s;
        Root = list(key, s);  // установка указателя на корень
    }
    while (1)                //добавление элементов
    {
        cout << "\nВведите ключ: ";  cin >> key;
        if (key < 0) break;       //признак выхода (ключ < 0)   
        cout << "Введите слово: ";  cin >> s;
        insertElem(Root, key, s);
    }
    return Root;
}
Tree* list(int i, char* s)     //Создание нового элемента
{
    Tree* t = new Tree[sizeof(Tree)];
    t->key = i;
    for (i = 0; i < 5; i++)
        *((t->text) + i) = *(s + i);
    t->Left = t->Right = NULL;
    return t;
}

Tree* insertElem(Tree* Root, int key, char* s)
{
    if (!Root)   //если дерево пустое
    {
        Root = list(key, s);   //создаем корень
        return Root;
    }
    Tree* temp = Root;   //временный указатель на корень
    while (temp)
    {
        if (key < temp->key)  //если ключ меньше, чем в текущем узле, идем влево
        {
            if (temp->Left)
            {
                temp = temp->Left;
            }
            else
            {
                temp->Left = list(key, s);  //если левый указатель пустой, создаем новый элемент
                return Root;
            }
        }
        else   //иначе идем вправо
        {
            if (temp->Right)
            {
                temp = temp->Right;
            }
            else
            {
                temp->Right = list(key, s);  //если правый указатель пустой, создаем новый элемент
                return Root;
            }
        }
    }
    return Root;   //возвращаем указатель на корень дерева
}

Tree* delet(Tree* Root, int key)  //Удаление элемента по ключу
{  // Del, Prev_Del - удаляемый элемент и его предыдущий ;
  // R, Prev_R - элемент, на который заменяется удаленный, и его родитель; 
    Tree* Del, * Prev_Del, * R, * Prev_R;
    Del = Root;
    Prev_Del = NULL;
    while (Del != NULL && Del->key != key)//поиск элемента и его родителя 
    {
        Prev_Del = Del;
        if (Del->key > key)
            Del = Del->Left;
        else
            Del = Del->Right;
    }
    if (Del == NULL)              // элемент не найден
    {
        puts("\nНет такого ключа");
        return Root;
    }
    if (Del->Right == NULL) // поиск элемента R для замены
        R = Del->Left;
    else
        if (Del->Left == NULL)
            R = Del->Right;
        else
        {
            Prev_R = Del; //поиск самого правого элемента в левом поддереве
            R = Del->Left;
            while (R->Right != NULL)
            {
                Prev_R = R;
                R = R->Right;
            }
            if (Prev_R == Del) // найден элемент для замены R и его родителя Prev_R 
                R->Right = Del->Right;
            else
            {
                R->Right = Del->Right;
                Prev_R->Right = R->Left;
                R->Left = Prev_R;
            }
        }
    if (Del == Root) Root = R;  //удаление корня и замена его на R
    else
        // поддерево R присоединяется к родителю удаляемого узла
        if (Del->key < Prev_Del->key)
            Prev_Del->Left = R; // на левую ветвь 
        else
            Prev_Del->Right = R;  // на правую ветвь
    int tmp = Del->key;
    cout << "\nУдален элемент с ключом " << tmp << endl;
    delete Del;
    return Root;
}

Tree* search(Tree* n, int key)  //Поиск элемента по ключу 
{
    Tree* rc = n;
    if (rc != NULL)
    {
        if (key < (key, n->key))
            rc = search(n->Left, key);
        else
            if (key > (key, n->key))
                rc = search(n->Right, key);
    }
    else
        cout << "Нет такого элемента\n";
    return rc;
}

int count(Tree* t, char letter) //Подсчет количества слов
{
    if (t)
    {
        count(t->Right, letter);
        if (*(t->text) == letter)
            c++;
        count(t->Left, letter);
    }
    return c;
}

void view(Tree* t, int level) //Вывод дерева 
{
    if (t)
    {
        view(t->Right, level + 1);  //вывод правого поддерева
        for (int i = 0; i < level; i++)
            cout << "   ";
        int tm = t->key;
        cout << tm << ' ';
        puts(t->text);
        view(t->Left, level + 1);  //вывод левого поддерева
    }
}

void delAll(Tree* t) //Очистка дерева
{
    if (t != NULL)
    {
        delAll(t->Left);
        delAll(t->Right);
        delete t;
    }
}

void levelOrderTraversal(Tree* root)
{
    if (root == nullptr) {
        return;
    }

    queue<Tree*> q;
    q.push(root);

    while (!q.empty()) {
        int size = q.size();

        for (int i = 0; i < size; i++) {
            Tree* node = q.front();
            q.pop();

            cout << "(" << node->key << ", " << node->text << ") ";

            if (node->Left != nullptr) {
                q.push(node->Left);
            }

            if (node->Right != nullptr) {
                q.push(node->Right);
            }
        }

        cout << endl;
    }
}

int countRightLeaves(Tree* root) {
    if (root == NULL) {
        return 0;
    }
    if (root->Right == NULL && root->Left == NULL) {
        return 1;
    }
    return countRightLeaves(root->Left) + countRightLeaves(root->Right);
}

int countNodesWithValueK(Tree* node, int k) {
    if (node == NULL) {
        return 0;
    }
    int count = 0;
    if (node->key == k) {
        count++;
    }
    count += countNodesWithValueK(node->Left, k);
    count += countNodesWithValueK(node->Right, k);
    return count;
}

int sumOfKeys(Tree* node) {
    if (node == NULL) {  // базовый случай: пустое дерево
        return 0;
    }
    else {  // рекурсивный случай: не пустое дерево
        return node->key + sumOfKeys(node->Left) + sumOfKeys(node->Right);
    }
}

int countEvenKeys(Tree* node) {
    if (node == NULL) {
        return 0;
    }

    int count = 0;
    if (node->key % 2 == 0) {
        count++;
    }

    count += countEvenKeys(node->Left);
    count += countEvenKeys(node->Right);

    return count;
}

void printLevelSum(Tree* p1) {
    if (p1 == nullptr) {
        return; // обработка пустого дерева
    }
    queue<Tree*> q;
    q.push(p1);
    int level = 0;
    int levelSum = 0;
    int nodesLeftOnLevel = 1;
    while (!q.empty()) {
        Tree* currentNode = q.front();
        q.pop();
        levelSum += currentNode->key;
        if (currentNode->Left != nullptr) {
            q.push(currentNode->Left);
        }
        if (currentNode->Right != nullptr) {
            q.push(currentNode->Right);
        }
        nodesLeftOnLevel--;
        if (nodesLeftOnLevel == 0) {
            cout << "Level " << level << " sum: " << levelSum << endl;
            level++;
            levelSum = 0;
            nodesLeftOnLevel = q.size();
        }
    }
}