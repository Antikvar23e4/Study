use NEM_MyBASE;
/*1 Использовать в секции WHERE преди-кат IN c некоррелированным подзапросом.
получение информации о выполненных операциях средней сложности.*/
SELECT Операции.Название_операции, Производство.Дата_выполнения
FROM Операции, Производство
WHERE Операции.Код_операции = Производство.Код_операции
AND Операции.Код_операции IN (
    SELECT Код_операции
    FROM Производство
    WHERE Сложность_операции LIKE 'Средняя%'
);


/*2 подзапрос был записан в конструкции INNER JOIN секции FROM внешнего запроса */
SELECT Операции.Название_операции, Производство.Дата_выполнения
FROM Операции
INNER JOIN Производство ON Операции.Код_операции = Производство.Код_операции
WHERE Операции.Код_операции IN (
    SELECT Код_операции
    FROM Производство
    WHERE Сложность_операции LIKE 'Средняя%'
);


/*3 использовать соединение INNER JOIN трех таблиц */
SELECT Операции.Название_операции, Производство.Дата_выполнения, Работники.Фамилия, Работники.Имя
FROM Операции
INNER JOIN Производство ON Операции.Код_операции = Производство.Код_операции
INNER JOIN Работники ON Производство.Идентификатор_работника = Работники.Идентификатор_работника
WHERE Операции.Код_операции IN (
    SELECT Код_операции
    FROM Производство
    WHERE Сложность_операции LIKE 'Средняя%'
);

/*4 использовать коррелируемый подзапрос c секциями TOP и ORDER BY. 
номер заказа, в котором он выполнил наибольшее количество деталей.*/
SELECT
Работники.Фамилия,
Работники.Имя,
Работники.Отчество,
    (SELECT TOP 1 Производство.Номер_заказа
     FROM Производство
     WHERE Производство.Идентификатор_работника = Работники.Идентификатор_работника
     ORDER BY Производство.Количество_деталей DESC) AS Больше_всего_деталей
FROM Работники;

/*5 Использовать предикат EXISTS и кор-релированный подзапрос. 
найти всех работников, которые выполнили хотя бы одну операцию в производстве.  */
SELECT Фамилия, Имя, Отчество
FROM Работники
WHERE EXISTS (
    SELECT 1
    FROM Производство
    WHERE Производство.Идентификатор_работника = Работники.Идентификатор_работника
);


/*6 использовать три некоррелированных под-запроса в списке SELECT; в подзапросах применить агрегатные функции AVG*/
SELECT 
top(1)
(SELECT  AVG(Количество_деталей) FROM Производство WHERE [Код_операции] = 111) AS 'Среднее_колличество_111',
(SELECT AVG(Количество_деталей) FROM Производство WHERE [Код_операции] = 231) AS 'Среднее_колличество_231',
(SELECT  AVG(Количество_деталей) FROM Производство WHERE [Код_операции] = 123) AS 'Среднее_колличество_123'
FROM Производство;

/*7 Разработать SELECT-запрос, демон-стрирующий способ применения ALL совместно с подзапросом.
 поиск работников, у которых все операции имеют количество деталей, равное или большее 90*/
SELECT Фамилия,Имя,Отчество, Стаж_работы
FROM Работники
WHERE 90 <= ALL (
    SELECT Количество_деталей
    FROM Производство
    WHERE Работники.Идентификатор_работника = Производство.Идентификатор_работника
);

/*8 Разработать SELECT-запрос, демон-стрирующий принцип применения ANY совместно с подзапросом. 
для поиска работников, у которых есть хотя бы одна операция  с количеством деталей менее 90.*/
SELECT  Фамилия,Имя,Отчество, Стаж_работы
FROM Работники
WHERE 90 > ANY (
    SELECT Количество_деталей
    FROM Производство
    WHERE Работники.Идентификатор_работника = Производство.Идентификатор_работника
);
