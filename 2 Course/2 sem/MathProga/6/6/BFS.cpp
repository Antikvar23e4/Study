#include "stdafx.h" 
#include "BFS.h"

//  инициализации данных перед обходом графа
void BFS::init(const graph::AList& al, int s)
{
	this->al = &al; // ”становка указател€ на список смежности
	this->c = new Color[this->al->nV]; // —оздание массива цветов вершин
	this->d = new int[this->al->nV]; // —оздание массива рассто€ний до вершин
	this->p = new int[this->al->nV]; // —оздание массива предшественников вершин

	// »нициализаци€ массивов
	for (int i = 0; i < this->al->nV; i++)
	{
		this->c[i] = WHITE; // ¬се вершины помечаютс€ как не посещенные
		this->d[i] = INF; // –ассто€ни€ до всех вершин устанавливаютс€ как бесконечность
		this->p[i] = NIL; // ѕредшественники всех вершин устанавливаютс€ в NIL
	}

	this->c[s] = GRAY; // ѕометка стартовой вершины как посещенной (серой)
	this->d[s] = 0; // –ассто€ние до стартовой вершины устанавливаетс€ как 0
	this->q.push(s); // ƒобавление стартовой вершины в очередь дл€ обработки
}

//  онструктор дл€ структуры BFS, принимающий список смежности и стартовую вершину s
BFS::BFS(const graph::AList& al, int s)
{
	this->init(al, s); 
}

//  онструктор дл€ структуры BFS, принимающий матрицу смежности и стартовую вершину s
BFS::BFS(const graph::AMatrix& am, int s)
{
	this->init(*(new graph::AList(am)), s); // ѕреобразование матрицы смежности в список смежности 
}

// ћетод дл€ получени€ вершины из очереди дл€ обработки
int BFS::get()
{
	int rc = NIL, v = NIL;
	if (!this->q.empty()) // ѕроверка, не пуста ли очередь
	{
		rc = this->q.front(); // ѕолучение первой вершины из очереди
		for (int j = 0; j < this->al->size(rc); j++) // ѕеребор всех соседних вершин текущей вершины
			if (this->c[v = this->al->get(rc, j)] == WHITE) // ≈сли соседн€€ вершина бела€ (не посещена)
			{
				this->c[v] = GRAY; // ѕометка соседней вершины как посещенной (серой)
				this->d[v] = this->d[rc] + 1; // ”становка рассто€ни€ до соседней вершины
				this->p[v] = rc; // ”становка предшественника дл€ соседней вершины
				this->q.push(v); // ƒобавление соседней вершины в очередь дл€ обработки
			}
		this->q.pop(); // ”даление текущей вершины из очереди
		this->c[rc] = BLACK; // ѕометка текущей вершины как посещенной (черной)
	}
	return rc; // ¬озврат текущей вершины
}
