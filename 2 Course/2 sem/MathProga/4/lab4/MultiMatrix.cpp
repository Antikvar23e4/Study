#include "stdafx.h" 
#include <memory.h> // Для работы с памятью

// Расстановка скобок (рекурсия)
#define INFINITY  0x7fffffff // Бесконечность (максимальное значение int)
#define NINFINITY 0x80000000 // Минус бесконечность (минимальное значение int)

// Функция для рекурсивного расчёта оптимального расположения скобок
int OptimalM(int i, int j, int n, const int c[], int* s)
{
#define OPTIMALM_S(x1,x2)  (s[(x1-1)*n+x2-1]) // Макрос для доступа к элементам массива s

	int o = INFINITY; // Инициализация переменной o максимальным значением int
	int bo = INFINITY; // Инициализация переменной bo максимальным значением int

	if (i < j) // Условие выхода из рекурсии
	{
		for (int k = i; k < j; k++) // Перебор всех возможных разбиений
		{
			bo = OptimalM(i, k, n, c, s) + OptimalM(k + 1, j, n, c, s) + c[i - 1] * c[k] * c[j]; // Вычисление оптимального значения для текущего разбиения
			if (bo < o) // Если найдено новое минимальное значение
			{
				o = bo; // Обновление минимального значения
				OPTIMALM_S(i, j) = k; // Запоминание разбиения
			}
		}
	}
	else
		o = 0; // Базовый случай: одно число, нет операции умножения

	return o; // Возвращаем оптимальное значение
#undef OPTIMALM_S // Удаляем определение макроса
};

// Расстановка скобок (динамическое программирование)
int OptimalMD(int n, const int c[], int* s)
{
#define OPTIMALM_S(x1,x2)  (s[(x1-1)*n+x2-1]) // Макрос для доступа к элементам массива s
#define OPTIMALM_M(x1,x2)  (M[(x1-1)*n+x2-1]) // Макрос для доступа к элементам массива M

	int* M = new int[n * n]; // Выделение памяти для массива M
	int j = 0, q = 0; // Инициализация переменных j и q

	for (int i = 1; i <= n; i++)
		OPTIMALM_M(i, i) = 0; // Инициализация диагонали массива M нулями

	for (int l = 2; l <= n; l++) // Цикл по длинам подцепочек
	{
		for (int i = 1; i <= n - l + 1; i++) // Цикл по начальным индексам подцепочек
		{
			j = i + l - 1; // Вычисление конечного индекса подцепочки
			OPTIMALM_M(i, j) = INFINITY; // Инициализация текущего элемента массива M максимальным значением int
			for (int k = i; k <= j - 1; k++) // Цикл по возможным разбиениям подцепочек
			{
				q = OPTIMALM_M(i, k) + OPTIMALM_M(k + 1, j) + c[i - 1] * c[k] * c[j]; // Вычисление оптимального значения для текущего разбиения
				if (q < OPTIMALM_M(i, j)) // Если найдено новое минимальное значение
				{
					OPTIMALM_M(i, j) = q; // Обновление минимального значения
					OPTIMALM_S(i, j) = k; // Запоминание разбиения
				}
			}
		}
	}

	int result = OPTIMALM_M(1, n); // Результат хранится в верхнем правом углу матрицы M

	delete[] M; // Освобождение памяти, выделенной для массива M
	return result; // Возвращаем оптимальное значение
#undef OPTIMALM_M // Удаляем определение макроса
#undef OPTIMALM_S // Удаляем определение макроса
};
