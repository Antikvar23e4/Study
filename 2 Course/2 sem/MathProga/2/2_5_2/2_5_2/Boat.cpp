#include "pch.h"
#include "Boat.h"
#include "Combi.h"

namespace boatfnc
{
    // —равнение весов контейнеров с ограничени€ми по местам
    bool compv(combi::accomodation s, const int ming[],
        const int maxg[], const int v[])
    {
        // ѕроверка, что вес каждого контейнера в пределах соответствующих ограничений дл€ текущего размещени€
        int i = 0;
        while (i < s.m && v[s.ntx(i)] <= maxg[i] && v[s.ntx(i)] >= ming[i])i++;
        return (i == s.m);
    };
    // ¬ычисление суммарного дохода дл€ текущего размещени€
    int calcc(combi::accomodation s, const int c[])
    {
        int rc = 0;
        // —уммирование дохода от перевозки каждого контейнера в текущем размещении
        for (int i = 0; i < s.m; i++) rc += c[s.ntx(i)];
        return rc;
    };
    //  опирование содержимого массива r2 в массив r1
    void copycomb(short m, short* r1, const short* r2)
    {
        for (int i = 0; i < m; i++)  r1[i] = r2[i];
    };
}
int boat_с(      // функци€ возвращает доход от перевозки контейнеров
    short m,      // [in] количество мест дл€ контейнеров
    int minv[],   // [in] минимальный вес контейнера на каждом  месте 
    int maxv[],   // [in] максимальный вес коннтейнера каждом месте 
    short n,      // [in] всего контейнеров  
    const int v[],// [in] вес каждого контейнера  
    const int c[],// [in] доход от перевозки каждого контейнера   
    short r[]     // [out] номера выбранных контейнеров  
)
{
    combi::accomodation s(n, m);  // —оздание объекта дл€ генерации размещений
    int rc = 0, i = s.getfirst(), cc = 0;  // »нициализаци€ переменных дл€ хранени€ результата и состо€ни€ генератора
    while (i > 0)
    {
        // ѕроверка, что текущее размещение удовлетвор€ет ограничени€м по весу
        if (boatfnc::compv(s, minv, maxv, v))
        {
            // ¬ычисление суммарного дохода от текущего размещени€
            if ((cc = boatfnc::calcc(s, c)) > rc)
            {
                rc = cc;  // ќбновление максимального дохода
                boatfnc::copycomb(m, r, s.sset);  //  опирование текущего размещени€
            }
        }
        i = s.getnext();  // ѕолучение следующего размещени€
    };
    return rc;  // ¬озврат максимального дохода
}
